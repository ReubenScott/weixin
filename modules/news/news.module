<?php

include(ROOT.'includes/xmlrpc.inc');

/**
 * 财经新闻
 *
 */
class News {
    
  //构造函数
  public function __construct(){

  }
  
  /**
   * 获取财经新闻
   *
   * @return unknown
   */
  public function get_news(){
    //xmlrpc_client.php
    //XML-RPC客户端演示程序
      
    //创建client对象, 三个参数依次为 path, hostname, port  
    $s= new xmlrpc_client('/xmlrpc.php', 'www.loveslicai.com', 80);
    
    //create an array of parameters
    //create xmlrpcval object, which allows the encoding of our variable
    //创建xmlrpcval对象，将我们的PHP变量编码为XML-RPC需要的XML形式
    //尽管我们只有一个参数，但仍然要转换成数组的形式，因为xmlrpcmsg的第二个参数是一个参数表
    //$parameters=array($inputString);
    
    $parameters = array(
    //         new xmlrpcval(1234 ),
       new xmlrpcval("ABCDEFHIJ"),
    //         new xmlrpcval(1)
    ) ;
    
    //create the message object
    //创建XML-RPC报文，参数分别为 远程方法名 和 参数表
    $msg = new xmlrpcmsg('news.finance_news', $parameters);
    
    //send the message, get the response
    //发送报文，返回值$rsp为一个xmlrpcresp对象，它包含以下三个方法：
    //faultCode() 出错代码，如果成功将返回0
    //faultString() 出错信息
    //value() 返回值，以xmlrpcval对象形式存在，PHP使用前需要进行解码
    $rsp = $s->send($msg);
    
    //check for errors
    if($rsp->faultcode()==0) {
      //decode the response to a PHP type
      //xmlrpc_decode()函数用于将xmlrpcval对象解码
      $response = xmlrpc_decode($rsp->value());
      
      $content[] = json_decode($response, true); 
      
      return $content;
    } else {
//      print "<h3>Testing request serialization</h3>\n";
//      $op = $msg->serialize();
//      print "<PRE>" . htmlentities($op) . "</PRE>";
      //print errors
      return 'Error: '.$rsp->faultcode().', '.$rsp->faultstring().'';
    }
    
    
  }
  
  
  
}

